// Generated by CoffeeScript 2.1.0
(function() {
  var CreateReactClass, PropTypes, React, ReactCountdownClock;

  React = require('react');

  PropTypes = require('prop-types');

  CreateReactClass = require('create-react-class');

  ReactCountdownClock = CreateReactClass({
    _seconds: 0,
    _maxSeconds: 0,
    _radius: null,
    _fraction: null,
    _content: null,
    _canvas: null,
    _timeoutIds: [],
    _scale: window.devicePixelRatio || 1,
    displayName: 'ReactCountdownClock',
    componentDidUpdate: function(prevProps) {
      if (prevProps.seconds !== this.props.seconds) {
        this._seconds = this.props.seconds;
        this._maxSeconds = this.props.maxSeconds;
        this._stopTimer();
        this._setupTimer();
      }
      if (prevProps.color !== this.props.color) {
        this._clearBackground();
        this._drawBackground();
        this._updateCanvas();
      }
      if (prevProps.paused !== this.props.paused) {
        if (!this.props.paused) {
          this._startTimer();
        }
        if (this.props.paused) {
          return this._pauseTimer();
        }
      }
    },
    componentDidMount: function() {
      this._seconds = this.props.seconds;
      if (this._maxSeconds > 0) {
        this._percentOfMax = this._seconds / this._maxSeconds;
      } else {
        this._percentOfMax = 1;
      }
      return this._setupTimer();
    },
    componentWillUnmount: function() {
      return this._cancelTimer();
    },
    _setupTimer: function() {
      this._setScale();
      this._setupCanvases();
      this._drawBackground();
      this._drawTimer();
      if (!this.props.paused) {
        return this._startTimer();
      }
    },
    _updateCanvas: function() {
      this._clearTimer();
      return this._drawTimer();
    },
    _setScale: function() {
      this._radius = this.props.size / 2;
      this._fraction = 2 / this._seconds;
      this._tickPeriod = this._calculateTick();
      return this._innerRadius = this.props.weight ? this._radius - this.props.weight : this._radius / 1.8;
    },
    _calculateTick: function() {
      var tick, tickScale;
      // Tick period (milleseconds) needs to be fast for smaller time periods and slower
      // for longer ones. This provides smoother rendering. It should never exceed 1 second.
      tickScale = 1.8;
      tick = this._seconds * tickScale;
      if (tick > 1000) {
        return 1000;
      } else {
        return tick;
      }
    },
    _setupCanvases: function() {
      if (this._background && this._timer) {
        return;
      }
      this._background = this.refs.background.getContext('2d');
      this._background.scale(this._scale, this._scale);
      this._timer = this.refs.timer.getContext('2d');
      this._timer.textAlign = 'center';
      this._timer.textBaseline = 'middle';
      this._timer.scale(this._scale, this._scale);
      if (this.props.onClick != null) {
        return this.refs.component.addEventListener('click', this.props.onClick);
      }
    },
    _startTimer: function() {
      // Give it a moment to collect it's thoughts for smoother render
      return this._timeoutIds.push(setTimeout(() => {
        return this._tick();
      }), 200);
    },
    _pauseTimer: function() {
      this._stopTimer();
      return this._updateCanvas();
    },
    _stopTimer: function() {
      var i, len, ref, results, timeout;
      ref = this._timeoutIds;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        timeout = ref[i];
        results.push(clearTimeout(timeout));
      }
      return results;
    },
    _cancelTimer: function() {
      this._stopTimer();
      if (this.props.onClick != null) {
        return this.refs.component.removeEventListener('click', this.props.onClick);
      }
    },
    _tick: function() {
      var start;
      start = Date.now();
      return this._timeoutIds.push(setTimeout((() => {
        var duration;
        duration = (Date.now() - start) / 1000;
        this._seconds -= duration;
        if (this._seconds <= 0) {
          this._seconds = 0;
          this._handleComplete();
          return this._clearTimer();
        } else {
          this._updateCanvas();
          return this._tick();
        }
      }), this._tickPeriod));
    },
    _handleComplete: function() {
      if (this.props.onComplete) {
        return this.props.onComplete();
      }
    },
    _clearBackground: function() {
      return this._background.clearRect(0, 0, this.refs.timer.width, this.refs.timer.height);
    },
    _clearTimer: function() {
      return this._timer.clearRect(0, 0, this.refs.timer.width, this.refs.timer.height);
    },
    _drawBackground: function() {
      this._background.beginPath();
      this._background.globalAlpha = this.props.alpha / 3;
      this._background.fillStyle = this.props.color;
      this._background.arc(this._radius, this._radius, this._radius, 0, Math.PI * 2, false);
      this._background.arc(this._radius, this._radius, this._innerRadius, Math.PI * 2, 0, true);
      this._background.closePath();
      return this._background.fill();
    },
    _formattedTime: function() {
      var decimals, hours, hoursStr, minutes, minutesStr, ref, seconds, secondsStr, timeParts;
      decimals = (ref = this._seconds <= 9.9 && this.props.showMilliseconds) != null ? ref : {
        1: 0
      };
      if (this.props.timeFormat === 'hms') {
        hours = parseInt(this._seconds / 3600) % 24;
        minutes = parseInt(this._seconds / 60) % 60;
        seconds = (this._seconds % 60).toFixed(decimals);
        hoursStr = `${hours}`;
        minutesStr = `${minutes}`;
        secondsStr = `${seconds}`;
        if (hours < 10) {
          hoursStr = `0${hours}`;
        }
        if (minutes < 10 && hours >= 1) {
          minutesStr = `0${minutes}`;
        }
        if (seconds < 10 && (minutes >= 1 || hours >= 1)) {
          secondsStr = `0${seconds}`;
        }
        timeParts = [];
        if (hours > 0) {
          timeParts.push(hoursStr);
        }
        if (minutes > 0 || hours > 0) {
          timeParts.push(minutesStr);
        }
        timeParts.push(secondsStr);
        return timeParts.join(':');
      } else {
        return this._seconds.toFixed(decimals);
      }
    },
    _fontSize: function(timeString) {
      var scale, size;
      if (this.props.fontSize === 'auto') {
        scale = (function() {
          switch (timeString.length) {
            case 8:
              return 4; // hh:mm:ss
            case 5:
              return 3; // mm:ss
            default:
              return 2; // ss or ss.s
          }
        })();
        size = this._radius / scale;
        return `${size}px`;
      } else {
        return this.props.fontSize;
      }
    },
    _drawTimer: function() {
      var formattedTime, percent, text;
      percent = this._fraction * this._seconds * this._percentOfMax + 1.5;
      formattedTime = this._formattedTime();
      text = (this.props.paused && (this.props.pausedText != null)) ? this.props.pausedText : formattedTime;
      // Timer
      this._timer.globalAlpha = this.props.alpha;
      this._timer.fillStyle = this.props.color;
      this._timer.font = `bold ${this._fontSize(formattedTime)} ${this.props.font}`;
      this._timer.fillText(text, this._radius, this._radius);
      this._timer.beginPath();
      this._timer.arc(this._radius, this._radius, this._radius, Math.PI * 1.5, Math.PI * percent, false);
      this._timer.arc(this._radius, this._radius, this._innerRadius, Math.PI * percent, Math.PI * 1.5, true);
      this._timer.closePath();
      return this._timer.fill();
    },
    render: function() {
      var canvasProps, canvasStyle;
      canvasStyle = {
        position: 'absolute',
        width: this.props.size,
        height: this.props.size
      };
      canvasProps = {
        style: canvasStyle,
        height: this.props.size * this._scale,
        width: this.props.size * this._scale
      };
      return <div ref='component' className="react-countdown-clock" style={{
          width: this.props.size,
          height: this.props.size
        }}>
      <canvas ref='background' {...canvasProps}></canvas>
      <canvas ref='timer' {...canvasProps}></canvas>
    </div>;
    }
  });

  ReactCountdownClock.propTypes = {
    seconds: PropTypes.number,
    size: PropTypes.number,
    weight: PropTypes.number,
    color: PropTypes.string,
    fontSize: PropTypes.string,
    font: PropTypes.string,
    alpha: PropTypes.number,
    timeFormat: PropTypes.string,
    onComplete: PropTypes.func,
    onClick: PropTypes.func,
    showMilliseconds: PropTypes.bool,
    paused: PropTypes.bool,
    pausedText: PropTypes.string
  };

  ReactCountdownClock.defaultProps = {
    seconds: 60,
    size: 300,
    color: '#000',
    alpha: 1,
    timeFormat: 'hms',
    fontSize: 'auto',
    font: 'Arial',
    showMilliseconds: true,
    paused: false
  };

  module.exports = ReactCountdownClock;

}).call(this);
